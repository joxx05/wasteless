package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"

	"github.com/joxx05/wasteless/graph/model"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: CreateUser - createUser"))
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: GetUser - getUser"))
}

// ListUsers is the resolver for the listUsers field.
func (r *queryResolver) ListUsers(ctx context.Context, page int32, limit int32) (*model.UserPagination, error) {
	if limit <= 0 {
		limit = 10
	}
	if page <= 0 {
		page = 1
	}

	offset := (page - 1) * limit

	// ----------- COUNT TOTAL ITEMS -----------
	var totalItems int32
	err := r.DB.QueryRow(ctx, "SELECT COUNT(*) FROM users").Scan(&totalItems)
	if err != nil {
		return nil, fmt.Errorf("count users error: %w", err)
	}

	// ----------- GET USERS WITH PAGINATION -----------
	rows, err := r.DB.Query(ctx,
		`SELECT id, first_name, last_name, email, phone, province, district, ward, created_at, updated_at
        FROM users ORDER BY id DESC LIMIT $1 OFFSET $2`,
		limit, offset,
	)
	if err != nil {
		return nil, fmt.Errorf("query users error: %w", err)
	}
	defer rows.Close()

	users := []*model.User{}

	for rows.Next() {
		u := &model.User{}

		err := rows.Scan(
			&u.ID,
			&u.FirstName,
			&u.LastName,
			&u.Email,
			&u.Phone,
			&u.Province,
			&u.Ward,
			&u.CreatedAt,
			&u.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("scan error: %w", err)
		}

		users = append(users, u)
	}

	totalPages := (totalItems + limit - 1) / limit

	return &model.UserPagination{
		Items:       users,
		TotalItems:  totalItems,
		TotalPages:  totalPages,
		CurrentPage: page,
		PageSize:    limit,
	}, nil
}
